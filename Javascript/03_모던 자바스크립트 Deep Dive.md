책 : 모던 자바스크립트 Deep Dive(이웅모)

# 자바스크립트 기본 개념
- ES6(ECMAScript 2015) : let/const, 클래스, 화살표 함수, 템플릿 리터럴, 디스트럭처링 할당, 스프레드 문법, rest 파라미터, 심벌, 프로미스, Map/Set, 이터러블, for...of, 제너레이터, Proxy, 모듈 import/export
- Ajax : 1999년, 자바스크립트를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 기능이다. Asynchronous JavaScript and XML, 웹페이지에서 변경할 필요가 없는 부분은 다시 렌더링하지 않고, 서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 한정적으로 렌더링하는 방식이 가능해졌다. 
- Node.js : 2009년, Ryan Dahl이 발표한 Node.js는 구글 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경이다. Node.js는 브라우저의 자바스크립트 엔진에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서도 동작할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경이다. 주로 서버 사이드 애플리케이션 개발에 사용되며, 이에 필요한 모듈, 파일시스템, HTTP 등 빌트인 API를 제공한다.
  * Node.js는 데이터를 실시간으로 처리하기 위해 I/O가 빈번하게 발생하는 SPA(Single Page Application)에 적합하다. 하지만 CPU 사용률이 높은 애플리케이션에는 권장되지 않는다.
  * Node.js는 클라이언트 사이드 Web API를 지원하지 않고 ECMAScript와 Node.js 고유의 API를 지원한다.
  * npm : npm(node package manage)은 자바스크립트 패키지 매니저다. Node.js에서 사용할 수 있는 모듈
  > SPA란 : 어떤 웹 사이트의 전체 페이지를 하나의 페이지에 담아 동적으로 화면을 바꿔가며 표현하는 것이 SPA이다. 뭔가를 클릭하거나 스크롤하면, 상호작용하기 위한 최소한의 요소만 변경이 일어난다. 페이지 변경이 일어난다고 보여지는 것 또한 최초 로드된 자바스크립트를 통해 미리 브라우저에 올라간 템플릿만 교체되는 것이다.
- SPA 프레임워크 : CBD(Component based development) 방법론을 기반으로 하는 SPA가 대중화되면서 Angular, React, Vue.js, Svelte 등 다양한 SPA프레임워크/라이브러리가 사용되고 있다.
- ECMAScript : 자바스크립트의 표준 사양인 ECMA-262를 말하며, 프로그래밍 언어의 값, 타입, 객체와 프로퍼티, 함수, 표준 빌트인 객체 등 핵심 문법을 규정한다. 각 브라우저 제조사는 ECMAScript 사양을 준수해서 브라우저에 내장되는 자바스크립트 엔진을 구현한다. 
  * 자바스크립트는 일반적으로 ECMAScript를 기본 뼈대로 갖는 개념이며, 브라우저가 별도 지원하는 클라이언트 사이드 Web API를 아우르는 개념이다. Web API는 ECMAScript와 별도로 W3C에서 별도의 사양으로 관리하고 있다(https://developer.mozilla.org/ko/docs/Web/API).
- 자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어다.(클래스 기반 객체지향 언어보다 효율적이면서 강력한 프로토타입 기반의 객체지향 언어다).

## 변수
- 메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체다. 메모리 셀 하나의 크기는 1바이트(8비트)이며, 컴퓨터는 메모리 셀의 크기, 즉 1바이트 단위로 데이터를 저장하거나 읽어들인다. 각 셀은 고유의 메모리 주소(memory address)를 갖는다.
- 변수(variable) : 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. 즉, 변수는 값의 위치를 가리키는 상징적인 이름이다. 
  * 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 변수 이름이라고 하고, 변수에 저장된 값을 변수 값이라고 한다. 변수에 값을 저장하는 것을 할당(assignment)이라 하고, 변수에 저장된 값을 읽어들이는 것을 참조(reference)라 한다. 
  * 식별자(identifier) : 변수 이름을 식별자라고도 한다(변수, 함수, 클래스 등의 이름은 모두 식별자다). 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다. 식별자는 값이 아니라 메모리 주소를 기억하고 있다. 즉, 식별자는 메모리 주소에 붙인 이름이라고 할 수 있따. 
- 변수를 사용할 때는 반드시 선언이 필요하다. 변수 선언은 선언 단계(변수 이름 등록)와 초기화 단계(메모리 공간 확보하고 undefined 할당)를 거친다.
  * var 키워드는 블록레벨 스코프를 지원하지 않아, 의도하지 않게 전역 변수가 선언되어 심각한 부작용이 발생하기도 한다.
- 변수 이름 등 모든 식별자는 실행 컨텍스트에 등록된다. 변수 이름과 변수 값은 실행 컨텍스트 내에 Key / Value 형식인 객체로 등록되어 관리된다. 
> 실행 컨텍스트(execution context)는 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. 자바스크립트 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리한다.

- 변수 호이스팅(variable hoisitng) : 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라 한다. 자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행한다. 따라서 변수 선언이 소스코드의 어디에 위치하는지와 상관없이 어디서든지 변수를 참조할 수 있다. 변수 선언뿐 아니라 var, elt, const, functino, class 키워드를 사용해서 선언하는 모든 식별자는 호이스팅된다. 
- 변수 재할당 : 변수에 값을 재할당하면 변수의 값은 이전 값에서 재할당한 값으로 변경된다. 처음 값을 할당했을 때와 마찬가지로 이전 값이 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 재할당 값을 새롭게 저장하는 것이 아니라 새 메모리 공간을 확보하고 그 메모리 공간에 새 변수 값을 저장한다. 
- Garbage Collecotr : 가비지 콜렉터는 애플리케이션이 할당(allocate)한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제(release)하는 기능을 말한다. 더 이상 사용되지 않는 메모리란 간단히 말하자면 어떤 식별자도 참조하지 않는 메모리 공간을 의미한다. 자바스크립트는 가비지 콜렉터를 내장하고 있는 managed language(개발자가 직접적으로 메모리 제어 불가)로서 가비지 콜렉터를 통해 메모리 누수를 방지한다.
- 식별자 네이밍 규칙 : 자바스크립트에서는 일반적으로 변수나 함수의 이름에는 카멜 케이스(firstName)를 사용하고, 생성자 함수, 클래스 이름에는 파스칼 케이스(FirstName)을 사용한다. 


## 표현식과 문
- 값(value) : 값은 식(expression)이 평가(evaluate, 식을 해석해서 값 생성 또는 참조)되어 생성된 결과를 말한다. 모든 값은 데이터 타입을 가지며, 메모리에 2진수(bit)의 나열로 저장된다.
- 리터럴(literal) : 리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다. 
- 표현식(expression) : 값으로 평가될 수 있는 문(statement)은 모두 표현식이다.
- 문(statement) : 문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위다. 문의 집합으로 이뤄진 것이 바로 프로그램이다.(var = sum 1 + 2;) 
  * 표현식인 문 : 값으로 평가되므로 변수에 할당할 수 있다.(ex, x=100; //할당문은 그 자체가 표현식이지만 완전한 문이기도 하다.)
  * 표현식이 아닌 문 : 값으로 평가할 수 없으므로 변수에 할당하면 에러가 난다.(ex, var x; //변수 선언문은 표현식이 아닌 문이다.)
- 토큰(token) : 문은 여러 토큰으로 구성된다. 토큰이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.(var, sum, =, 1, +, 2, ;) 


## 데이터 타입
- 자바스크립트(ES6)는 7개의 데이터 타입을 제공한다.
  - 원시 타입
    1. 숫자 타입 : 자바스크립트에서 숫자 타입은 모두 실수로만 처리된다. 숫자 타입은 추가적으로 세 가지 특별한 값(Infinity, -Infinity, NaN)도 표현할 수 있다.
    2. 문자열 타입 : 템플릿 리터럴(백틱 사용)은 멀티라인 문자열과 표현식 삽입을 가능하게 한다. (ex, console.log(\`1 + 2 = %{1 + 2}.\`);)
    3. 불리언 타입 : true, false
    4. undefined 타입 : 변수 선언한 이후 값을 할당하지 않은 변수를 참조하면 undefined가 반환된다. undefined는 개발자가 아니라 자바스크립트 엔진이 변수를 초기화할 때 사용하는 타입이다.  
    5. null 타입 : 개발자가 변수에 값이 없다는 것을 의도적으로 명시하고 싶을 때는 undefined가 아니라 null을 사용한다. 
    6. symbol 타입 (ES6에서 추가된 7번째 타입) : 심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다. 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다. Symbol 함수를 호출해 생성한다. 
        ```js
        var key = Symbol('key');
        var obj = {}
        //이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용한다.
        obj[key] = 'value';
        console.log(obj[key]); //value
        ```
  - 객체 타입(객체, 함수, 배열 등)

- 데이터 타입이 필요한 이유
  * 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
  * 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
  * 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

- 동적 타이핑
  * 자바스크립트는 동적 타입 언어로서 변수를 선언할 때 타입을 선언하지 않는다. 다만 var, let, const 키워드를 사용해 변수를 선언할 뿐이다. 자바스크립트의 변수는 정적 타입 언어와 같이 미리 선언한 데이터 타입의 값만 할당할 수 있는 것이 아니다. 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있다.
  * 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론 type inference)된다. 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 이러한 특징을 동적 타이핑이라 한다. 대표적 동적 타입 언어로는 자바스크립트, 파이썬, 루비 등이 있다.
  * 변수는 타입을 갖지 않고 값이 타입을 가지므로 현재 변수에 할당되어 있는 값에 의해 타입이 동적으로 결정된다.(변수는 값에 묶여 있는 값에 대한 별명이다)
  * 동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다. (개발자 의도와 상관없이 타입이 자동으로 변환될 수도 있기 때문)

## 연산자
연산자(operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다. 이때 연산의 대상을 피연산자(operand)라 한다. 피연산자는 값으로 평가될 수 있는 표현식이어야 한다. 
- 증가/감소(++/--)연산자는 피연산자의 값을 변경하는 부수 효과가 있으며, 위치에 의미가 있다.
  * 피연산자 앞에 위치한 전위 증가/감소 연산자는 먼저 피연자의 값을 증가/감소시킨 후, 다른 연산을 수행한다.
    ```js
    var x = 5, result;
    result = ++x;
    console.log(result, x); //6 6
    ```
  * 피연산자 뒤에 위치한 후위 증가/감소 연산자는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소시킨다.
    ```js
    var x = 5, result;
    result = x++; //x의 값(5)을 result에 할당한 다음, x의 값을 증가(6)시킨다. 
    console.log(result, x); //5 6
    ```
- 비교 연산자
  * 동등 비교 연산자(==, !=)는 느슨한 비교(값만 비교)를 하지만 일치 비교 연산자(===, !==)는 엄격한 비교(값과 타입 모두 비교)를 한다.
    ```js
    // 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 동등하다. 
    5 == '5'; // true
    ```
    + 동등 비교 연산자는 예측하기 어렵고 실수할 수 있어 사용하지 않는 편이 좋고, 대신 일치 비교 연산자를 사용한다.
    + 일치 비교 연산자에서 주의할 것은 NaN이다. NaN은 자신과 일치하지 않는 유일한 값이다. 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 isNaN을 사용한다.
      ```js
      NaN === NaN; // false
      isNaN(NaN); // true
      ```
    + Object.is 메서드 : ES6에서 도입된 이 메서드는 다음과 같이 예측 가능한 정확한 비교 결과를 반환한다.
      ```js
      -0 === +0; //true
      Object.is(-0, +0); //false
      NaN === NaN; //false
      Object.is(NaN, NaN); true
      ```
- 삼항 조건 연산자(ternary operator) : 조건식의 평가 결과에 따라 반환할 값을 사용한다. 물음표 앞의 첫 번째 피연산자는 조건식, 즉 불리언 타입의 값으로 평가될 표현식이고, 조건식이 참이면 콜론 앞의 두 번째 피연산자가 평가되어 반환되고, 거짓이면 콜론 뒤의 세 번째 피연산자가 평가되어 반환된다. 삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다. 
  ```js
  var result = score >= 60 ? 'pass' : 'fail';
- 논리 연산자(logical operator)
  * || : 논리합(OR)
  * && : 논리곱(AND)
  * ! : 부정(NOT), 논리부정 연산자는 언제나 불리언 값을 반환한다. 만약 피연사자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환된다. 
- typeof 연산자 : 피연산자의 데이터 타입을 7가지 문자열(string, number, boolean, undefined, symbol, object, function) 중 하나로 반환한다. 이처럼 typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 정확히 일치하지는 않는다
  * null의 타입은 object로 반환됨에 주의하자. 값이 null 타입인지 확인할 때는 typeof 연산자를 사용하지 말고 일치 연산자(===)를 사용하자.
  ```js
  var foo = null;
  typeof foo === null; // false
  foo === null; // true
  ```
- delete 연산자 : 객체의 프로퍼티를 삭제한느 부수 효과가 있다. 
 ```js
 var o = { a : 1 };
 delete o.a;
 console.log(o); //{}
 ```
 
## 제어문
- 블록문 : 문을 중괄호로 묶은 것이다. 블록문은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문에 블록문의 끝에는 세미콜론을 붙이지 않는다.
- 조건문
  * if...else 문
  ```js
  if (조건식1) {
  } else if (조건식2) {
  } else {
  }
  ```
  삼항 조건 연산자로 바꿔 쓸 수 있다. 경우의 수가 세 가지 다음과 같이 바꿔 쓸 수도 있다.
  ```js
  //0은 false로 취급된다
  var kind = num ? (num>0 ? '양수' : '음수') : '영'; 
  ```
  * switch문 : 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 흐름을 옮긴다. 
  ```js
  switch (표현식) {
    case 표현식1:
      //switch 문의 표현식과 표현식1이 일치되면 실행될 문;
      break;  // fall through가 나타지 않도록 break 문을 사용해야 한다.
    case 표현식2:
      //switch 문의 표현식과 표현식2가 일치되면 실행될 문;
      break;
    default:
      //switch 문의 표현식과 일치하는 case 문이 없을 때 실행될 문;
  }
  ```
- 반복문
  * 1. for 문 : 반복 횟수가 명확할 때 주로 사용한다.
  ```js
  for (변수 선언문 또는 할당문; 조건식; 증감식) {
    조건식이 참인 경우 반복 실행될 문;
  }
  ```
  * 2. while 문 : 반복 횟수가 불명확할 때 주로 사용한다.
  ```js
  var count = 0;
  while (true) {
    console.log(count);
    count++;
    if (count === 3) break;  //무한루프 탈출하려면 코드 블록 내에 if 문으로 조건을 만들고 break 문으로 코드 블록 탈출
  }
  ```
  * 3. do...while 문 : 코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드 블록은 무조건 한 번 이상 실행된다. 
  ```js
  var count = 0;
  do {
    console.log(count); // 0 1 2
    count++;
  } while(count <3);
  ```
  * 반복문을 대체할 수 있는 다양한 기능 : 배열을 순회할 때 사용하는 forEach메서드, 객체의 프로퍼티를 열거할 때 사용하는 for...in 문, ES^에서 도입된 이터러블을 순회할 수있는 for...of 문과 같이 반복문을 대체할 수 있는 기능들도 있다.

- break 문 : label 문, 반복문, switch 문의 코드 블록 외에 break 문을 사용하면 SyntaxError가 발생한다. 
  * label 문 : 식별자가 붙은 문이며, 프로그램의 실행 순서를 제어하는 데 사용한다. 
  ```js
  //foo라는 식별자가 붙은 레이블 블록문
  foo: {
    console.log(1);
    break foo; //foo 레이블 블록문을 탈출한다.
    console.log(2);
  }
  console.log('Done!');
  ```
- continue 문 : 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다. break 문처럼 반복문을 탈출하지는 않는다.  

## 타입 변환과 단축 평가
- 논리 연산자를 사용한 단축평가 : 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다. 이를 단축평가라 한다. 단축평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.
true || anything   ->   true
  * false || anything   ->  anything
  * true && anything   ->   anything
  * false && anything   ->  false
   ```js
   console.log(
  'Cat' || 'Dog',  //Cat
  false || 'Dog',  //Dog
  'Cat' || false,  //Cat
  'Cat' && 'Dog',  //Dog
  false && 'Dog',  //false
  'Cat' && false)  //false
  ```
- 객체는 key와 value로 구성된 프로퍼티의 집합이다. 만약 객체를 가리키기를 기대하는 변수의 값이 객체가 아니라 null 또는 undefined인 경우 객체의 프로퍼티를 참조하면 타입 에러가 발생하고 프로그램이 강제 종료된다. 이때 단축 평가를 발생하면 에러를 발생시키지 않는다.
  ```js
  var elem = null;
  var value = elem && elem.value; // -> null
  ```
  * 옵셔널 체이닝 연산자 : ES11에 도입된 옵셔널 체이닝 연산자 ?.는 좌항의 연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다. 옵셔널 체이닝 연산자 ?.는 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때 유용하다. 옵셔널 체이닝 연산자 ?.가 도입되기 이전에는 논리 연산자 &&를 사용한 단축 평가를 통해 변수가 null 또는 undefined인지 확인했다.
   ```js
   var value = elem?.value;
   ```
  * null 병합 연산자 : ES11에서 도입된 null 병합 연산자 ??는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다. null 병합 연산자 ??는 변수에 기본값을 설정할 때 유용하다. null 병합 연산자 ??가 도입되기 이전에는 논리 연산자 ||를 사용한 단축 평가를 통해 변수에 기본값을 설정했다. 
 ```js
 var foo = null ?? 'default string';
 console.log(foo); // "default string"
 ```
- 함수를 호출할 때 인수를 전달하지 않으면 매개변수에는 undefined가 할당된다. 이때 단축 평가를 사용해 매개변수의 기본값을 설정하면 undefined로 인해 발생할 수 있는 에러를 방지할 수 있다.

## 객체 리터럴
- 객체(object) : 자바스크립트는 객체 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 '모든 것'이 객체다. 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등) 모두 객체다.원시 값은 단 하나의 값을 나타내며 변경 불가능한 값이지만, 객체는 복합적인 자료구조며 변경 가능한 값이다. 객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 key와 value로 구성된다.
  * 함수도 객체의 프로퍼티 값으로 사용될 수 있으며, 이처럼 프로퍼티 값으로 사용된 함수는 일반 함수와 구분하기 위해 method라 부른다. 즉 객체는 프로퍼티와 메서드로 구성된 집합체다.
    + 프로퍼티 : 객체의 상태를 나타내는 값(data)
    + 메서드 : 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)
![다운로드](https://user-images.githubusercontent.com/59413128/135813148-4ab11911-7722-40fa-93e3-19c212b26178.png)

- 자바스크립트는 '프로토타입 기반 객체지향 언어'로서 '클래스 기반 객체지향 언어(C++,자바)'와는 달리 다양한 객체 생성 방법을 지원한다. 
  * 객체 리터럴, Object 생성자 함수, 생성자 함수, Object.create 메서드, 클래스(ES6)
 > C++나 자바 같은 클래스 기반 객체지향 언어는 클래스를 사전에 정의하고 필요한 시점에 new 연산자와 함께 생성자(constructor)를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성한다.
 > > 인스턴스란 클래스에 의해 생성되어 메모리에 저장된 실체를 말한다. 객체지향 프로그래밍에서는 객체는 클래스와 인스턴스를 포함한 개념이다. 클래스는 인스턴스를 생성하기 위한 템플릿의 역할을 한다. 인스턴스는 객체가 메모리에 저장되어 실제로 존재하는 것에 초점을 맞춘 용어다.
- 객체 리터럴에 의한 객체 생성(가장 일반적이며 간단한 방법)
  * 객체 리터럴은 중괄호 내에 0개 이상의 프로퍼티를 정의한다. 
  ```js
  var person = {
    name: 'Lee',
    sayHello: function() {
      console.log('Hello! My name is %{this.name}');
    }
  };
  console.log(typeof person); //object
  console.log(person); // {name: "Lee", sayHello: f}
  ```
  
- 프로퍼티 : 객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다. 프로퍼티를 나열할 때는 쉼표로 구분한다.
  * 문자열 또는 문자열로 평가할 수 있는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수도 있다 .이 경우에는 프로퍼티 키로 사용할 표현식을 대괄호로 묶어야 한다. 
  ```js
  var obj = {};
  var key = 'hello';
  obj[key] = 'world';
  //var obj = { [key]: 'world};
  console.log(obj); // {hello: "world"}
  ```
  
- 프로퍼티 접근
  * 마침표 표기법
  ```js
  var person = {
    name: 'Lee'
  };
  console.log(person.name);  //Lee
  ```
  * 대괄호 표기법 : 대괄호 표기법을 사용하는 경우 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다.
  ```js
  console.log(person['name']; //Lee
  ```
- 프로퍼티 삭제 : delete 연산자
```js
var person = {
  name: 'Lee'
};
delete person.name;
```

- ES6에 추가된 객체 리터럴의 확장 기능
  * 프로퍼티 축약 표현 : 프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략할 수 있다. 이때 프로퍼티 키는 변수 이름으로 자동 생성된다.
  ```js
  let x=1, y=2;
  const obj = {x,y};  //이전에는  var obj = {x: x, y: y}라고 했어야 했다.
  ``` 
  * 계산된 프로퍼티 이름 : 문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수도 있다. 단, 프로퍼티 키로 사용할 표현식을 대괄호로 묶어야 한다.
  ```js
  const prefix = 'prop';
  let i =0;
  //객체 리터럴 내부에서 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성
  const obj = {
    [`${prefix}-${++i}`]: i,
    [`${prefix}-${++i}`]: i,
    [`${prefix}-${++i}`]: i
  }
  console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
  ```
  * 메서드 축약 표현 : ES5에서 메서드를 정의하려면 프로퍼티 값으로 함수를 할당했으나, ES6에서는 메서드를 정의할 때 function 키워드를 생략한 축약 표현을 사용할 수 있다.
  ```js
  const ojb = {
    name: 'Lee',
    sayHi() {    //이전에는 sayHi: function()였음
      console.log('Hi!'+name);
    }
  };
  obj.sayHi(); //Hi! Lee
  ```
## 원시 값과 객체의 비교
- 원시 타입의 값
  1. 변경 불가능하다.
  2. 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다.
  3. 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달(pass by value)이라 한다.
- 객체(참조) 타입의 값
  1. 변경 가능하다.
  2. 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장된다.
  3. 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달(pass by reference)이라 한다.

- 유사 배열 객체(array-like object) : 유사 배열 객체란 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다. 문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있으며, length프로퍼티를 갖기 때문에 유사 배열 객체이고 for 문으로 순회할 수도 있다. 이치럼 원시 값인 문자열이 객체이기도 하다. 하지만 문자열은 원시 값이므로 값을 변경할 수 없다.
- 객체의 참조에 의한 전달 : 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이것은 두 개의 식별자가 하나의 객체를 공유한다는 것을 의미한다. 원본 또는 사본 중 어느 한쪽에서 객체를 변경(변수에 새로운 객체를 재할당하는 것이 아니라 객체의 프로퍼티 값을 변경하거나 프로퍼티를 추가, 삭제)하면 서로 영향을 주고받는다.

## 함수
- 프로그래밍 언어의 함수는 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다. 함수 내부로 입력을 전달받는 변수를 매개변수(parameter), 입력을 인수(argument), 출력을 반환값(return value)이라 한다. 함수는 몇 번이든 호출할 수 있으므로 코드의 재사용이라는 측면에서 매우 유용하다. 코드의 중복을 억제하고 재사용성을 높이는 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높인다. 
- 함수 리터럴 : 리터럴은 값을 생성하기 위한 표기법이며, 함수 리터럴도 평가되어 값을 생성한다. 즉, 함수는 객체다. 함수는 객체지만 일반 객체와 달리, 호출을 할 수 있으며 고유한 프로퍼티를 갖는다. 함수가 객체라는 사실은 다른 프로그래밍 언어와 구별되는 자바스크립트의 중요한 특징이다. 
  ```js
  // 변수에 함수 리터럴을 할당
  var f = function add(x,y) {
    return x+y;
  };
  ```
- 함수 정의 방식
  * 함수 선언문 : 함수 선언문은 함수 이름을 생략할 수 없다는 점을 제외하면 함수 리터럴과 형태가 동일하다. 함수 선언문은 표현식이 아닌 문이다.
    > 표현식이 아닌 문 : 값으로 평가할 수 없으므로 변수에 할당하면 에러가 난다.(ex, var x; //변수 선언문은 표현식이 아닌 문이다.) 
    ```js
    function add(x,y) {
      return x + y;
    }
  * 함수 표현식 : 자바스크립트의 함수는 입급 객체며, 이는 함수를 값처럼 자유롭게 사용할 수 있다는 의미다. 함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 함수 리터럴의 함수 이름은 생략할 수 있다. 이러한 함수를 익명 함수라 한다. 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다. 함수를 호출할 때는 함수 이름이 아니라 함수 객체를 가리키는 식별자를 사용해야 한다. 
    > 표현식인 문 : 값으로 평가되므로 변수에 할당할 수 있다.(ex, x=100; //할당문은 그 자체가 표현식이지만 완전한 문이기도 하다.)
   ```js
   var add = function foo (x, y) {  //함수 이름 foo 생략 가능
     return x + y; 
   };
   
   console.log(add(2,5)); 
   ```
  * 함수 생성 시점과 함수 호이스팅
    + 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다. 이는 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다. 함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성된다. 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당한다. 이처럼 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅이라 한다. 
      ```js
      console.dir(add); // f add(x,y)
      console.log(add(2,5); // 7
      
      function add(x, y) {
        return x + y;
      }
      ```
    + 그러나 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다. 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다. g 따라서 함수 표현식으로 정의한 함수는 반드시 함수 표현식 이후에 참조 또는 호출해야 한다. 
      ```js
      console.dir(sub); // undefined
      console.log(sub(2,5)); // TypeError : sub is not a function
      
      var sub = function (x, y) {
        return x - y;
      }
      ```
     >  함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시한다. 이 같은 문제 때문에 함수 선언문 대신 함수 표현식 사용이 권장되기도 한다.
  * Function 생성자 함수 : 빌트인 함수인 Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열에 전달하면서 new 연산자와 함께 호출하면 함수 객체를 생성해서 반환한다. 사실 new 연산자 없이 호출하면 결과는 동일하다. 이 방식은 일반적이지 않으며 바람직하지도 않다. 클로저를 생성하지 않는 등, 다른 함수 생성 방식과 다르게 동작한다.
     > 생성자 함수(constructor function)는 객체를 생성하는 함수를 말한다. 객체를 생성하는 방식은 객체 리터럴 이외에 다양한 방법이 있다.
     ```js
     var add = new Function('x', 'y', 'return x+y');
     console.log(add(2,5));  //7
     ```
  * 화살표 함수(arrow function) : ES6에서 도입되었고 function 키워드 대신 화살표를 사용해 좀 더 간략한 방법으로 함수를 선언할 수 있다. 화살표 함수는 항상 익명 함수로 정의한다. 
    ```js
    const add = (x, y) => x + y;
    console.log(add(2,5)); // 7
    ```
- 함수 호출
  * 매개변수와 인수 : 매개변수를 통해 인수를 전달한다. 인수는 함수를 호출할 때 지정하며, 개수와 타입에 제한이 없다. 함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 안흔다. 인수가 부족해서 인수가 할당되지 않은 매개변수의 값은 undefined다. 매개변수보다 인수가 더 많은 경우 초과된 인수는 무시된다. 
  * 매개변수와 최대 개수 : 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다. 매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다. 만약 그 이 상의 매개변수가 필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달하는 것이 유리하다.
  * 반환문
    + 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다. 따라서 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다.
    + 반환문은 return 키워드 뒤에 오는 표현식을 평가해 반환한다. return 키워드 뒤에 반환값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다. 
- 참조에 의한 전달과 외부 상태의 변경 : 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 순수 함수라 한다. 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임을 함수형 프로그래밍이라 한다.
- 다양한 함수의 형태
  * 즉시 실행 함수 : 함수 정의와 동시에 즉시 실행되는 함수를 즉시 실행 함수라고 하며, 이는 단 한 번만 호출되며 다시 호출할 수 없다. 즉시 실행 함수는 반드시 그룹 연산자 (...)로 감싸야 한다. 즉시 실행 함수 내에 코드를 모아 두면 혹시 있을 수도 있는 변수나 함수 이름의 충돌을 방지할 수 있다.
  * 재귀 함수 : 함수가 자기 자신을 호출하는 것을 재귀 호출이라 한다. 재귀 함수는 자기 자신을 호출하는 행위, 즉 재귀 호출을 수행하는 함수를 말한다. 자기 자신을 호출하는 재귀 함수를 사용하면 반복되는 처리를 반복문 없이 구현할 수 있다. 재귀 함수 내에는 재귀 호출을 멈출 수 있는 탈출 조건을 반드시 만들어야 한다. 찰출 조건이 없으면 함수가 무한 호출되어 스택 오버플로 에러가 발생한다. 
   ```js
   function factorial(n) {
     // 탈출 조건 : n이 1 이하일 때 재귀 호출을 멈춘다.
     if (n<=1) return 1;
     // 재귀 호출
     return n * factorial(n-1);
   }
   
   console.log(factorial(5)); // 5! = 5*4*3*2*1 = 120
   ```
  * 중첩 함수 : 함수 내부에 정의된 함수를 중첩 함수 또는 내부 함수라 한다. 그리고 중첩 함수를 포함하는 함수는 외부 함수라 부른다. 중첩 함수는 외부 함수 내부에서만 호출할 수 있다. 일반적으로 중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수의 역할을 한다. 
  * 콜백 함수 : 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고 하며, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수라고 한다. 고차 함수는 콜백 함수를 자신의 일부분으로 합성한다. 고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다. 콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다. 함수형 패러다임, 비동기 처리(이벤트 처리, Ajax 통신, 타이머 함수 등)에 활용되는 중요한 패턴이다.
  ```js
  function repeat(n, f) {
    for (var i =0; i < n; i++) {
      f(i);
    }
  }

  var logOdds = function (i) {
     if (i % 2) console.log(i);
   };

  repeat(5, logOdds);
  ```
- 함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임이다. 로직 내에 존재하는 조건문과 반복문을 제거해서 복잡성을 해결하며, 변수 사용을 억제하거나 생명주기를 최소화해서 상태 변경을 피해 오류를 최소화하는 것을 목표로 한다. 

## 스코프
스코프(scope, 유효범위)는 식별자가 유효한 범위를 말한다. 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 스코프란 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙이라고도 할 수 있다. 프로그래밍 언어에서는 스코프(유효 범위)를 통해 식별자인 변수 이름의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있게 한다. 스코프 내에서 식별자는 유일해야 하지만 다른 스코프에서 같은 이름의 식별자를 사용할 수 있다. 즉, 스코프는 네임스페이스다.
> 코드가 어디서 실행되며 주변에 어떤 코드가 있는지를 렉시컬 환경이라고 부른다. 즉, 코드의 문맥은 렉시컬 환경으로 이뤄진다. 이를 구현한 것이 실행 컨텍스트(execution context)이며 모든 코드는 실행 컨텍스트에서 평가되고 실행된다. 

```js
var x = 'global';  //전역 스코프

function foo() {
  var x = 'local';  // foo 함수 스코프
  console.log(x);  // local
}

foo();

console.log(x);  //global
```
전역 변수는 어디서든지 참조할 수 있다. 지역 변수는 지역 스코프와 하위 지역 스코프에서 유효하다. 
- 렉시컬 스코프
  * 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 동적 스코프가 아닌 렉시컬 스코프를 따른다. 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다. 즉, 함수의 상위 스코프는 언제나 자신이 정의된 스코프다. 
  > 렉시컬 스코프(함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 정의한다) vs 동적 스코프(함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 정의한다)    
 ```js
 var x = 1;
function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```

## 전역 변수의 문제점
전역 변수의 무분별한 사용은 위험하므로, 되도록 지역 변수를 사용한다.
- 지역 변수의 생명주기 : 지역 변수의 생명주기는 함수의 생명 주기와 일치한다. 
  ```js
  function foo() {
    var x = 'local'; //변수 x 생성
    console.log(x);
    return x; //변수 x 소멸
  }
  ```
- 전역 변수의 생명주기 : 브라우저 환경에서 전역 객체는 window이므로 브라우저 환경에서 var 키워드로 선언한 전역 변수는 전역 객체 window 프로퍼티다. 전역 객체 window는 웹페이지를 닫기 전까지 유효하다. 따라서 브라우저 환경에서 var 키워드로 선언한 전역 변수는 웹페이지를 닫을 때까지 유효하다. 즉, var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.
- 전역 변수의 사용을 억제하는 방법
  * 즉시 실행 함수 : 모든 코드를 '즉시 실행 함수'로 감싸면 모든 변수는 '즉시 실행 함수'의 지역 변수가 된다. 이 방법을 사용하면 전역 변수를 생성하지 않으므로 라이브러리 등에 자주 사용된다.
  ```js
  (function() {
    var foo = 10;
    //...
  }());
  
  console.log(foo);  //ReferenceError: foo is not defined
  ```
  
  * 네임스페이스 객체 : 전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이다. 
  ```js
  var MYAPP = {}; //전역 네임스페이스 객체
  MYAPP.name = 'Lee';
  console.log(MYAPP.name); //Lee
  ```
- 모듈 패턴 : 모듈 패턴은 클래스를 모방해서 관련이 있는 변수와 함수를 모아 '즉시 실행 함수'로 감싸 하나의 모듈을 만드는 것이다. 모듈 패턴의 특징은 전역 변수의 억제는 물론 캡슐화까지 구현할 수 있다는 것이다. 즉시 실행 함수에서 객체를 반환하면, 이 객체에는 외부에 노출하고 싶은 변수나 함수를 담아 반환한다. 이때 반환되는 객체의 프로퍼티는 외부에 노출되는 public member다. 외부로 노출하고 싶지 않은 변수나 함수는 반환하는 객체에 추가하지 않으면 외부에서 접근할 수 없는 private member가 된다.
 > 캡슐화는 객체의 프로퍼티와 메서드를 하나로 묶는 것을 말한다. 캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 정보 은닉이라 한다.
 ```js
 var Counter = (function () {
  //private 함수
  var num = 0;
  
  //외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
  return {
    increase() {
      return ++num;
    },
  };
}());

console.log(Counter.num);  //undefined
console.log(Counter.increase());  //1
```
- ES6 모듈 : ES6 모듈을 사용하면 더는 전역 변수를 사용할 수 없다. ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다. 따라서 모듈 내에서 var 키워드로 선언한 변수는 더는 전역 변수가 아니며 window 객체의 프로퍼티도 아니다. script 태그에 type="module" 속성을 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다. 모듈의 파일 확장자는 mjs를 권장한다.
```html
<script type="module" src="lib.mjs"></script>
```
  


  
 
