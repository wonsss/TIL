책 : 모던 자바스크립트 Deep Dive(이웅모)

# 자바스크립트 기본 개념
- ES6(ECMAScript 2015) : let/const, 클래스, 화살표 함수, 템플릿 리터럴, 디스트럭처링 할당, 스프레드 문법, rest 파라미터, 심벌, 프로미스, Map/Set, 이터러블, for...of, 제너레이터, Proxy, 모듈 import/export
- Ajax : 1999년, 자바스크립트를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 기능이다. Asynchronous JavaScript and XML, 웹페이지에서 변경할 필요가 없는 부분은 다시 렌더링하지 않고, 서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 한정적으로 렌더링하는 방식이 가능해졌다. 
- Node.js : 2009년, Ryan Dahl이 발표한 Node.js는 구글 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경이다. Node.js는 브라우저의 자바스크립트 엔진에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서도 동작할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경이다. 주로 서버 사이드 애플리케이션 개발에 사용되며, 이에 필요한 모듈, 파일시스템, HTTP 등 빌트인 API를 제공한다.
  * Node.js는 데이터를 실시간으로 처리하기 위해 I/O가 빈번하게 발생하는 SPA(Single Page Application)에 적합하다. 하지만 CPU 사용률이 높은 애플리케이션에는 권장되지 않는다.
  * Node.js는 클라이언트 사이드 Web API를 지원하지 않고 ECMAScript와 Node.js 고유의 API를 지원한다.
  * npm : npm(node package manage)은 자바스크립트 패키지 매니저다. Node.js에서 사용할 수 있는 모듈
  > SPA란 : 어떤 웹 사이트의 전체 페이지를 하나의 페이지에 담아 동적으로 화면을 바꿔가며 표현하는 것이 SPA이다. 뭔가를 클릭하거나 스크롤하면, 상호작용하기 위한 최소한의 요소만 변경이 일어난다. 페이지 변경이 일어난다고 보여지는 것 또한 최초 로드된 자바스크립트를 통해 미리 브라우저에 올라간 템플릿만 교체되는 것이다.
- SPA 프레임워크 : CBD(Component based development) 방법론을 기반으로 하는 SPA가 대중화되면서 Angular, React, Vue.js, Svelte 등 다양한 SPA프레임워크/라이브러리가 사용되고 있다.
- ECMAScript : 자바스크립트의 표준 사양인 ECMA-262를 말하며, 프로그래밍 언어의 값, 타입, 객체와 프로퍼티, 함수, 표준 빌트인 객체 등 핵심 문법을 규정한다. 각 브라우저 제조사는 ECMAScript 사양을 준수해서 브라우저에 내장되는 자바스크립트 엔진을 구현한다. 
  * 자바스크립트는 일반적으로 ECMAScript를 기본 뼈대로 갖는 개념이며, 브라우저가 별도 지원하는 클라이언트 사이드 Web API를 아우르는 개념이다. Web API는 ECMAScript와 별도로 W3C에서 별도의 사양으로 관리하고 있다(https://developer.mozilla.org/ko/docs/Web/API).
- 자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어다.(클래스 기반 객체지향 언어보다 효율적이면서 강력한 프로토타입 기반의 객체지향 언어다).

## 변수
- 메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체다. 메모리 셀 하나의 크기는 1바이트(8비트)이며, 컴퓨터는 메모리 셀의 크기, 즉 1바이트 단위로 데이터를 저장하거나 읽어들인다. 각 셀은 고유의 메모리 주소(memory address)를 갖는다.
- 변수(variable) : 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. 즉, 변수는 값의 위치를 가리키는 상징적인 이름이다. 
  * 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 변수 이름이라고 하고, 변수에 저장된 값을 변수 값이라고 한다. 변수에 값을 저장하는 것을 할당(assignment)이라 하고, 변수에 저장된 값을 읽어들이는 것을 참조(reference)라 한다. 
  * 식별자(identifier) : 변수 이름을 식별자라고도 한다(변수, 함수, 클래스 등의 이름은 모두 식별자다). 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다. 식별자는 값이 아니라 메모리 주소를 기억하고 있다. 즉, 식별자는 메모리 주소에 붙인 이름이라고 할 수 있따. 
- 변수를 사용할 때는 반드시 선언이 필요하다. 변수 선언은 선언 단계(변수 이름 등록)와 초기화 단계(메모리 공간 확보하고 undefined 할당)를 거친다.
  * var 키워드는 블록레벨 스코프를 지원하지 않아, 의도하지 않게 전역 변수가 선언되어 심각한 부작용이 발생하기도 한다.
- 변수 이름 등 모든 식별자는 실행 컨텍스트에 등록된다. 변수 이름과 변수 값은 실행 컨텍스트 내에 Key / Value 형식인 객체로 등록되어 관리된다. 
> 실행 컨텍스트(execution context)는 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. 자바스크립트 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리한다.

- 변수 호이스팅(variable hoisitng) : 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라 한다. 자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행한다. 따라서 변수 선언이 소스코드의 어디에 위치하는지와 상관없이 어디서든지 변수를 참조할 수 있다. 변수 선언뿐 아니라 var, elt, const, functino, class 키워드를 사용해서 선언하는 모든 식별자는 호이스팅된다. 
- 변수 재할당 : 변수에 값을 재할당하면 변수의 값은 이전 값에서 재할당한 값으로 변경된다. 처음 값을 할당했을 때와 마찬가지로 이전 값이 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 재할당 값을 새롭게 저장하는 것이 아니라 새 메모리 공간을 확보하고 그 메모리 공간에 새 변수 값을 저장한다. 
- Garbage Collecotr : 가비지 콜렉터는 애플리케이션이 할당(allocate)한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제(release)하는 기능을 말한다. 더 이상 사용되지 않는 메모리란 간단히 말하자면 어떤 식별자도 참조하지 않는 메모리 공간을 의미한다. 자바스크립트는 가비지 콜렉터를 내장하고 있는 managed language(개발자가 직접적으로 메모리 제어 불가)로서 가비지 콜렉터를 통해 메모리 누수를 방지한다.
- 식별자 네이밍 규칙 : 자바스크립트에서는 일반적으로 변수나 함수의 이름에는 카멜 케이스(firstName)를 사용하고, 생성자 함수, 클래스 이름에는 파스칼 케이스(FirstName)을 사용한다. 


## 표현식과 문
- 값(value) : 값은 식(expression)이 평가(evaluate, 식을 해석해서 값 생성 또는 참조)되어 생성된 결과를 말한다. 모든 값은 데이터 타입을 가지며, 메모리에 2진수(bit)의 나열로 저장된다.
- 리터럴(literal) : 리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다. 
- 표현식(expression) : 값으로 평가될 수 있는 문(statement)은 모두 표현식이다.
- 문(statement) : 문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위다. 문의 집합으로 이뤄진 것이 바로 프로그램이다.(var = sum 1 + 2;) 
  * 표현식인 문 : 값으로 평가되므로 변수에 할당할 수 있다.(ex, x=100; //할당문은 그 자체가 표현식이지만 완전한 문이기도 하다.)
  * 표현식이 아닌 문 : 값으로 평가할 수 없으므로 변수에 할당하면 에러가 난다.(ex, var x; //변수 선언문은 표현식이 아닌 문이다.)
- 토큰(token) : 문은 여러 토큰으로 구성된다. 토큰이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.(var, sum, =, 1, +, 2, ;) 


## 데이터 타입
- 자바스크립트(ES6)는 7개의 데이터 타입을 제공한다.
  - 원시 타입
    1. 숫자 타입 : 자바스크립트에서 숫자 타입은 모두 실수로만 처리된다. 숫자 타입은 추가적으로 세 가지 특별한 값(Infinity, -Infinity, NaN)도 표현할 수 있다.
    2. 문자열 타입 : 템플릿 리터럴(백틱 사용)은 멀티라인 문자열과 표현식 삽입을 가능하게 한다. (ex, console.log(\`1 + 2 = %{1 + 2}.\`);)
    3. 불리언 타입 : true, false
    4. undefined 타입 : 변수 선언한 이후 값을 할당하지 않은 변수를 참조하면 undefined가 반환된다. undefined는 개발자가 아니라 자바스크립트 엔진이 변수를 초기화할 때 사용하는 타입이다.  
    5. null 타입 : 개발자가 변수에 값이 없다는 것을 의도적으로 명시하고 싶을 때는 undefined가 아니라 null을 사용한다. 
    6. symbol 타입 (ES6에서 추가된 7번째 타입) : 심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다. 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다. Symbol 함수를 호출해 생성한다. 
        ```js
        var key = Symbol('key');
        var obj = {}
        //이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용한다.
        obj[key] = 'value';
        console.log(obj[key]); //value
        ```
  - 객체 타입(객체, 함수, 배열 등)

- 데이터 타입이 필요한 이유
  * 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
  * 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
  * 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

- 동적 타이핑
  * 자바스크립트는 동적 타입 언어로서 변수를 선언할 때 타입을 선언하지 않는다. 다만 var, let, const 키워드를 사용해 변수를 선언할 뿐이다. 자바스크립트의 변수는 정적 타입 언어와 같이 미리 선언한 데이터 타입의 값만 할당할 수 있는 것이 아니다. 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있다.
  * 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론 type inference)된다. 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 이러한 특징을 동적 타이핑이라 한다. 대표적 동적 타입 언어로는 자바스크립트, 파이썬, 루비 등이 있다.
  * 변수는 타입을 갖지 않고 값이 타입을 가지므로 현재 변수에 할당되어 있는 값에 의해 타입이 동적으로 결정된다.(변수는 값에 묶여 있는 값에 대한 별명이다)
  * 동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다. (개발자 의도와 상관없이 타입이 자동으로 변환될 수도 있기 때문)

## 연산자
연산자(operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다. 이때 연산의 대상을 피연산자(operand)라 한다. 피연산자는 값으로 평가될 수 있는 표현식이어야 한다. 
- 증가/감소(++/--)연산자는 피연산자의 값을 변경하는 부수 효과가 있으며, 위치에 의미가 있다.
  * 피연산자 앞에 위치한 전위 증가/감소 연산자는 먼저 피연자의 값을 증가/감소시킨 후, 다른 연산을 수행한다.
    ```js
    var x = 5, result;
    result = ++x;
    console.log(result, x); //6 6
    ```
  * 피연산자 뒤에 위치한 후위 증가/감소 연산자는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소시킨다.
    ```js
    var x = 5, result;
    result = x++; //x의 값(5)을 result에 할당한 다음, x의 값을 증가(6)시킨다. 
    console.log(result, x); //5 6
    ```
- 비교 연산자
  * 동등 비교 연산자(==, !=)는 느슨한 비교(값만 비교)를 하지만 일치 비교 연산자(===, !==)는 엄격한 비교(값과 타입 모두 비교)를 한다.
    ```js
    // 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 동등하다. 
    5 == '5'; // true
    ```
    + 동등 비교 연산자는 예측하기 어렵고 실수할 수 있어 사용하지 않는 편이 좋고, 대신 일치 비교 연산자를 사용한다.
    + 일치 비교 연산자에서 주의할 것은 NaN이다. NaN은 자신과 일치하지 않는 유일한 값이다. 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 isNaN을 사용한다.
      ```js
      NaN === NaN; // false
      isNaN(NaN); // true
      ```
    + Object.is 메서드 : ES6에서 도입된 이 메서드는 다음과 같이 예측 가능한 정확한 비교 결과를 반환한다.
      ```js
      -0 === +0; //true
      Object.is(-0, +0); //false
      NaN === NaN; //false
      Object.is(NaN, NaN); true
      ```
- 삼항 조건 연산자(ternary operator) : 조건식의 평가 결과에 따라 반환할 값을 사용한다. 물음표 앞의 첫 번째 피연산자는 조건식, 즉 불리언 타입의 값으로 평가될 표현식이고, 조건식이 참이면 콜론 앞의 두 번째 피연산자가 평가되어 반환되고, 거짓이면 콜론 뒤의 세 번째 피연산자가 평가되어 반환된다. 삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다. 
  ```js
  var result = score >= 60 ? 'pass' : 'fail';
- 논리 연산자(logical operator)
  * || : 논리합(OR)
  * && : 논리곱(AND)
  * ! : 부정(NOT), 논리부정 연산자는 언제나 불리언 값을 반환한다. 만약 피연사자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환된다. 
- typeof 연산자 : 피연산자의 데이터 타입을 7가지 문자열(string, number, boolean, undefined, symbol, object, function) 중 하나로 반환한다. 이처럼 typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 정확히 일치하지는 않는다
  * null의 타입은 object로 반환됨에 주의하자. 값이 null 타입인지 확인할 때는 typeof 연산자를 사용하지 말고 일치 연산자(===)를 사용하자.
  ```js
  var foo = null;
  typeof foo === null; // false
  foo === null; // true
  ```
- delete 연산자 : 객체의 프로퍼티를 삭제한느 부수 효과가 있다. 
 ```js
 var o = { a : 1 };
 delete o.a;
 console.log(o); //{}
 ```
 
## 제어문
- 블록문 : 문을 중괄호로 묶은 것이다. 블록문은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문에 블록문의 끝에는 세미콜론을 붙이지 않는다.
- 조건문
  * if...else 문
  ```js
  if (조건식1) {
  } else if (조건식2) {
  } else {
  }
  ```
  삼항 조건 연산자로 바꿔 쓸 수 있다. 경우의 수가 세 가지 다음과 같이 바꿔 쓸 수도 있다.
  ```js
  //0은 false로 취급된다
  var kind = num ? (num>0 ? '양수' : '음수') : '영'; 
  ```
  * switch문 : 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 흐름을 옮긴다. 
  ```js
  switch (표현식) {
    case 표현식1:
      //switch 문의 표현식과 표현식1이 일치되면 실행될 문;
      break;  // fall through가 나타지 않도록 break 문을 사용해야 한다.
    case 표현식2:
      //switch 문의 표현식과 표현식2가 일치되면 실행될 문;
      break;
    default:
      //switch 문의 표현식과 일치하는 case 문이 없을 때 실행될 문;
  }
  ```
- 반복문
  * 1. for 문 : 반복 횟수가 명확할 때 주로 사용한다.
  ```js
  for (변수 선언문 또는 할당문; 조건식; 증감식) {
    조건식이 참인 경우 반복 실행될 문;
  }
  ```
  * 2. while 문 : 반복 횟수가 불명확할 때 주로 사용한다.
  ```js
  var count = 0;
  while (true) {
    console.log(count);
    count++;
    if (count === 3) break;  //무한루프 탈출하려면 코드 블록 내에 if 문으로 조건을 만들고 break 문으로 코드 블록 탈출
  }
  ```
  * 3. do...while 문 : 코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드 블록은 무조건 한 번 이상 실행된다. 
  ```js
  var count = 0;
  do {
    console.log(count); // 0 1 2
    count++;
  } while(count <3);
  ```
  * 반복문을 대체할 수 있는 다양한 기능 : 배열을 순회할 때 사용하는 forEach메서드, 객체의 프로퍼티를 열거할 때 사용하는 for...in 문, ES^에서 도입된 이터러블을 순회할 수있는 for...of 문과 같이 반복문을 대체할 수 있는 기능들도 있다.

- break 문 : label 문, 반복문, switch 문의 코드 블록 외에 break 문을 사용하면 SyntaxError가 발생한다. 
  * label 문 : 식별자가 붙은 문이며, 프로그램의 실행 순서를 제어하는 데 사용한다. 
  ```js
  //foo라는 식별자가 붙은 레이블 블록문
  foo: {
    console.log(1);
    break foo; //foo 레이블 블록문을 탈출한다.
    console.log(2);
  }
  console.log('Done!');
  ```
- continue 문 : 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다. break 문처럼 반복문을 탈출하지는 않는다.  
