```jsx
1장 개요
1.1 패턴
1.2 자바스크립트의 개념
객체지향
클래스가 없다
프로토타입
실행 환경
1.3 ECMAScript 5
1.4 JSLint
1.5 콘솔

2장 기초
2.1 유지보수 가능한 코드 작성
2.2 전역 변수 최소화
전역 변수의 문제점
var 선언을 빼먹었을 때의 부작용
전역 객체에 대한 접근
단일 var 패턴
호이스팅(hoisting): 분산된 var 선언의 문제점
2.3 for 루프
2.4 for-in 루프
2.5 내장 생성자 프로토타입 확장하기 / 확장하지 않기
2.6 switch 패턴
2.7 암묵적 타입캐스팅 피하기
eval() 피하기
2.8 parseInt()를 통한 숫자 변환
2.9 코딩 규칙
들여쓰기
중괄호
여는 중괄호의 위치
공백
2 명명 규칙
생성자를 대문자로 시작하기
단어 구분
그 외의 명명 패턴
2 주석 작성
2 API 문서 작성
YUIDoc 예제
2 독자를 위한 문서 작성
2 동료 리뷰
2 출시 단계의 압축
2 JSLint 실행
2 요약

3장 리터럴과 생성자
3.1 객체 리터럴
객체 리터럴 문법
생성자 함수로 객체 생성하기
객체 생성자의 함정
3.2 사용자 정의 생성자 함수
생성자의 반환 값
3.3 new를 강제하는 패턴
명명 규칙
that 사용
스스로를 호출하는 생성자
3.4 배열 리터럴
배열 리터럴 문법
배열 생성자의 특이성
배열인지 판별하는 방법
3.5 JSON
JSON 다루기
3.6 정규 표현식 리터럴
정규 표현식 리터럴 문법
3.7 원시 데이터 타입 래퍼
3.8 에러 객체
3.9 요약

4장 함수
4.1 배경 지식
용어 정리
선언문 vs. 표현식: 이름과 호이스팅
함수의 name 프로퍼티
함수 호이스팅
4.2 콜백 패턴
콜백 예제
콜백과 유효범위
비동기 이벤트 리스너
타임아웃
라이브러리에서의 콜백
4.3 함수 반환하기
4.4 자기 자신을 정의하는 함수
4.5 즉시 실행 함수
즉시 실행 함수의 매개변수
즉시 실행 함수의 반환 값
장점과 사용 방법
4.6 즉시 객체 초기화
4.7 초기화 시점의 분기
4.8 함수 프로퍼티 - 메모이제이션(Memoization) 패턴
4.9 설정 객체 패턴
4 커리(Curry)
함수 적용
부분적인 적용
커링(Curring)
커링을 사용해야 할 경우
4 요약

5장 객체 생성 패턴
5.1 네임스페이스 패턴
범용 네임스페이스 함수
5.2 의존 관계 선언
5.3 비공개 프로퍼티와 메서드
비공개(private) 멤버
특권(privileged) 메서드
비공개 멤버의 허점
객체 리터럴과 비공개 멤버
프로토타입과 비공개 멤버
비공개 함수를 공개 메서드로 노출시키는 방법
5.4 모듈 패턴
모듈 노출 패턴
생성자를 생성하는 모듈
모듈에 전역 변수 가져오기
5.5 샌드박스 패턴
전역 생성자
모듈 추가하기
생성자 구현
5.6 스태틱 멤버
공개 스태틱 멤버
비공개 스태틱 멤버
5.7 객체 상수
5.8 체이닝 패턴
체이닝 패턴의 장단점
5.9 method() 메서드
5 요약

6장 코드 재사용 패턴
6.1 클래스 방식 vs. 새로운 방식의 상속 패턴
6.2 클래스 방식의 상속을 사용할 경우 예상되는 산출물
6.3 클래스 방식의 상속 패턴 #1 - 기본 패턴
프로토타입 체인 추적
패턴 #1의 단점
6.4 클래스 방식의 상속 패턴 #2 - 생성자 빌려쓰기
프로토타입 체인
생성자 빌려쓰기를 적용한 다중 상속
생성자 빌려쓰기 패턴의 장단점
6.5 클래스 방식의 상속 패턴 #3 - 생성자 빌려쓰고 프로토타입 지정해주기
6.6 클래스 방식의 상속 패턴 #4 - 프로토타입 공유
6.7 클래스 방식의 상속패턴 #5 - 임시 생성자
상위 클래스 저장
생성자 포인터 재설정
6.8 Klass
6.9 프로토타입을 활용한 상속
논의
ECMAScript 5의 추가사항
6 프로퍼티 복사를 통한 상속 패턴
6 믹스-인
6 메서드 빌려쓰기
예제: 배열 메서드 빌려쓰기
빌려쓰기와 바인딩
Function.prototype.bind()
6 요약

7장 디자인 패턴
7.1 싱글톤(Singleton)
new 사용하기
스태틱 프로퍼티에 인스턴스 저장하기
클로저에 인스턴스 저장하기
7.2 팩토리(Factory)
내장 객체 팩토리
7.3 반복자(Iterator)
7.4 장식자(Decorator)
사용 방법
구현
목록을 사용한 구현
7.5 전략
데이터 유효성 검사 예제
7.6 퍼사드(Facade)
7.7 프록시(Proxy)
예제
프록시를 사용해 요청 결과 캐시하기
7.8 중재자(Mediator)
중재자 패턴 예제
7.9 감시자(Observer)
예제 #1: 잡지 구독
예제 #2: 키 누르기 게임
7 요약

8장 DOM과 브라우저 패턴
8.1 관심사의 분리
8.2 DOM 스크립팅
DOM 접근
DOM 조작
8.3 이벤트
이벤트 처리
이벤트 위임
8.4 장시간 수행되는 스크립트
setTimeout()
웹워커
8.5 원격 스크립팅
XMLHttpRequest
JSONP
프레임과 이미지 비컨(Image Beacons)
8.6 자바스크립트 배포
스크립트 병합
코드 압축과 gzip 압축
Expires 헤더
CDN 사용
8.7 로딩 전략
〈script〉 엘리먼트의 위치
HTTP Chunked 인코딩 사용
다운로드를 차단하지 않는 동적인 〈script〉엘리먼트
게으른 로딩
주문형 로딩
자바스크립트 사전 로딩
8.8 요약
```

# 1장. 개요

## 1.1 패턴

- 소프트웨어 개발에서의 패턴이란 일반적인 문제에 대한 해결책을 가리킨다. 곧바로 복사해서 붙여넣을 수 있는 코드 형태의 답이 아니라, 모범적인 관행, 쓰임새에 맞게 추상화된 원리, 어떤 범주의 문제를 해결하는 템플릿에 더 가깝다.
    - 디자인 패턴
        - 싱글톤, 팩토리, 장식자(factory), 감시자(observer) 패턴 등이 있다.
        - 자바스크립트와 같이 느슨한 자료형의 동적인 언어의 경우에는 디자인 패턴을 적용하는 것이 말그대로 앞뒤가 안 맞아 보일 때도 있다.
    - 코딩 패턴
        - 함수의 다양한 활용과 같은 자바스크립트의 독톡한 기능과 연관된 훌륭한 실천 방법이다.
    - 안티패턴
        - 버그나 코딩 에러가 아니라, 문제를 해결하기보다는 오류를 더 많이 일으킬 수 있는 흔히 잘못 사용하는 접근 방법을 말한다.

## 1.2 자바스크립트의 개념

### 객체지향

- 자바스크립트는 객체지향 언어다. 함수도 객체다. 변수 선언 시 이미 객체를 다루는 것이다. 변수는 자신만의 프로퍼티를 가지기 때문에 실제로 객체와 비슷하다. 변수의 프로퍼티를 어트리뷰트라고 한다. 이 어트리뷰트의 값에 따라 해당 변수가 수정되거나 삭제될 수 있는지 혹은 for-in 루프로 순회할 때 열거될 수 있는지 등의 여부가 결정된다.
- 객체는 이름이 지정된 프로퍼티의 모음이며, 키-값 쌍으로 이뤄진 목록이다. 객체의 프로퍼티가 함수일 경우 이를 메서드라고 부른다.
- 반드시 기억해야 할 주요 객체 타입
    - 네이티브 객체
        - ECMAScript 표준에 정의된 객체
        - 내장 객체 또는 사용자 정의 객체로 분류된다.
    - 호스트 객체
        - 호스트 환경(예를 들면, 브라우저 환경)에서 정의된 객체
        - window 객체나 모든 DOM 객체를 예로 들 수 있다. 어떤 객체가 호스트 객체인지 궁금하다면 코드를 브라우저가 아닌 다른 환경에서 실행시켜 보면 된다. 만약 잘 동작한다면 네이티브 객체만을 사용하고 있는 것이다.

### 클래스가 없다.

### 프로토타입

상속을 할 수 있다. 프로토타입은 하나의 객체이며, 사용자가 생성한 모든 함수는 새로운 빈 객체를 가리키는 prototype 프로퍼티를 가진다. 프로토타입 객체는 객체 리터럴이나 Object() 생성자로 만든 객체와 거의 비슷하다. 

## 1.5 콘솔

코드 예제 출력

- log() 메서드
    - 전달된 모든 매개변수를 출력
- dir() 메서드
    - 전달된 객체를 열거하고 모든 프로퍼티를 출력

# 2장 기초

### 호이스팅: 분산된 var 선언의 문제점

- 자바스크립트에서는 함수 내 여기저기서 여러 개의 var 선언을 사용할 수 있지만, 실제로는 모두 함수 상단에서 변수가 선언된 것과 동일하게 동작한다. 이러한 동작 방식을 호이스팅이라고 한다.
- 혼란을 피하기 위해 사용할 변수를 모두 맨 첫 줄에서 선언하는 것이 좋다.

### 2.3 for 루프

```jsx
// 최적화X
for (var i=0; i<myarray.length; i++) {
	// myarray[i]를 다루는 코드	
}
```

위와 같은 일반적인 for 루프 패턴에서 문제점은 루프 순회시마다 배열의 length에 접근한다는 점이다.

HTMLCollection이라면 위와 같은 문제 때문에 코드가 느려질 수 있다. DOM 접근은 일반적으로 비용이 크다.

따라서 for 루프를 좀더 최적화하기 위해서는 다음 예제처럼 배열(또는 콜렉션)의 length를 캐시해야 한다.

```jsx
for (var i=0, max=myarray.length; i<max; i++) {
	// myarray[i]를 다루는 코드
}
```

### 2.4 for-in 루프

배열에는 일반적인 for 루프를 사용하고 객체에만 for-in 루프를 사용하는 것이 바람직하다.

배열 객체에 사용자가 정의한 기능이 추가되었다면 논리적인 오류가 발생할 수 있다.

- 객체의 프로퍼티를 순회할 때는 프로토타입 체인을 따라 상속되는 프로퍼티들을 걸러내기 위해 hasOwnProperty() 메서드를 사용해야 한다.

```jsx
for (var i in man) {
	if(Object.prototype.hasOwnProperty.call(man, i)) {
		console.log(i, ":", man[i]);
	}
}
```

### 2.8 parseInt()를 통한 숫자 변환

문자열을 숫자로 변환하는 방법으로는 다음과 같은 것들이 있다.

```jsx
+"08" // 8
Number("08") // 8
```

이 방법들은 대체로 parseInt()보다 빠르다. 하지만 parseInt()는 단순히 변환만 하는 것이 아니라 이름이 뜻하는 대로 파싱을 한다는 특징이 있다. 따라서 입력값으로 “08 hello”같은 값이 들어올 수 있다면 pasreInt()를 사용해야 숫자를 얻을 수 있다. 다른 방법을 사용하면 NaN이 반환되며 실패한다.

```jsx
parseInt("08 hello", 10) // 8
```

### 중괄호

항상 중괄호를 쓰고, 여는 중괄호는 선행하는 명령문과 동일한 행에 둔다.

중괄호 안에 있으면 들여쓴다.

## 2.10 명명 규칙

- 기능 암시
    - 상수나 전역 변수의 이름을 붙일 때 모든 글자를 대문자로 쓰는 규칙을 적용한다.
    - 비공개 메서드나 프로퍼티명에 접두어로 밑줄(_)을 붙여 구별하기 쉽게 해놓는다.
    

# 3장 리터럴과 생성자

- 이 책 여러 곳에서 ‘빈 객체'라는 표현을 보게 될 것이다. 하지만 이 표현은 간결성을 위한 것일 뿐 자바스크립트에 빈 객체란 없다는 사실을 알아두어야 한다. 가장 간단한 {} 객체조차도 이미 Object.prototype에서 상속받은 프로퍼티와 메서드를 가진다. ‘비어있다'는 말은 어떤 객체가 상속받은 것 외에는 자기 자신의 프로퍼티를 갖고 있지 않다는 뜻으로 이해하면 된다.
- 일반적으로 Date() 생성자를 제외하면 내장 생성자를 사용할 일은 거의 없다.

```jsx
내장 생성자(사용을 자제하라)
var o = new Object();
var a = new Array();
var re = new RegExp("[a-z]", "g");
var s = new String();
var n = new Number();
var b= new Boolean();
throw new Error("uh-oh");
```

```jsx
리터럴과 원시 데이터 타입(권장안)
var 0 = {};
var a = [];
var re = /[a-z]/g;
var s = "";
var n = 0;
var b= false;
throw {
  name: "Error",
  message: "uh-oh",
};
또는
ㄷ
throw Error("uh-oh")
```

# 4장 함수

### 용어 정리
- 함수 표현식
	- 기명 함수 표현식

```jsx
var add = function add(a, b) {
	return a + b;
};
```

	- 익명 함수 표현식
		- 함수 표현식의 기명과 익명의 유일한 차이점은 익명 함수 표현식의 name 프로퍼티가 빈 문자열이 된다는 것이다. name 프로퍼티는 ECMA 표준이 아니라 언어의 확장기능이지만 많은 실행 환경에서 폭넓게 사용된다.
		
```jsx
var add = function (a, b) {
	return a + b;
};
```

- 함수 선언문
	- 함수 표현식과 달리 세미콜론이 붙지 않는다.

```jsx
function foo() {

}
```

## 4.3 함수 반환하기

- 클로저는 반환되는 함수에서는 접근할 수 있지만 코드 외부에서는 접근할 수 없기 때문에, 비공개 데이터 저장을 위해 사용할 수 있다. 매번 호출할 때마다 값을 증가시키는 카운터를 예제로 들 수 있다.

```jsx
const setup = function () {
	let count = 0;
	return function () {
		return (count += 1);
	};
};

// 사용방법
const next = setup();
next(); // 1
next(); // 2
next(); // 3
```

## 4.4 즉시 실행 함수
- 장점
	- 즉시 실행 함수 패턴은 폭넓게 사용된다. 전역 변수를 남기지 않고 상당량의 작업을 할 수 있게 해준다. 
	- 선언된 모든 변수는 스스로를 호출하는 함수의 지역 변수가 되기 때문에 임시 변수가 전역 공간을 어지럽힐까봐 걱정하지 않아도 된다.

## 4.9 설정 객체 패턴
- 설정 객체 패턴은 좀더 깨긋한  API를 제공하는 방법이다. 이 패턴은 함수가 DOM 엘리먼트를 생성할 때나 엘리먼트의 CSS 스타일을 지정할 때 유용하다. 엘리먼트와 스타일은 많은 수의 어트리뷰트와 프로퍼티를 가지며 대부분은 선택적인 값이기 때문이다.

```jsx
var conf = {
	username: "batman",
	first: "Bruce",
	last: "Wayne",
};
addPerson(conf);
```

## 4.10 커리(Curry)

### 함수 적용

- 순수한 함수 프로그래밍 언어에서, 함수는 불려지거나 호출된다고 표현하기보다 적용(apply)된다고 표현한다. 
- 자바스크립트에서도 Function.prototype.apply()를 사용하면 함수를 적용할 수 있다. 

```jsx
const sayHi = function (who) {
	return "Hello" + (who ? ", " + who : "") + "!";
};

// 함수 호출
sayHi(); // "Hello"
sayHi('world'); // "Hello, world!"

// 함수 적용
sayHi.apply(null, ["Marco"]); // "Hello, Marco!"
```

- apply()는 두 개의 매개변수를 받는다.
	- 첫 번째는 이 함수 내에 this와 바인딩할 객체이고, 두 번째는 배열 또는 인자로 함수 내부에서 배열과 비슷한 형태의 arguments 객체로 사용하게 된다.
	- 첫 번째 매개변수가 null 일때는 this는 전역 객체를 가리킨다. 즉 함수를 특정 객체의 메서드로서가 아니라 일반적인 함수로 호출하는 것이다.
- 함수가 객체의 메서드일 때는, 위 예제처럼 null을 전달하지 않는다.

```jsx
const alien = {
	sayHi: function (who) {
		return "Hello" + (who ? ", " + who : "") + "!";
	}
};

alien.sayHi('world'); // "Hello, world!"
sayHi.apply(alien, ["humans"]); // "Hello, humans!"
```

- 위 코드에서 sayHi() 내부의 this는 alien을 가리킨다. 앞선 예제에서 this는 전역 객체를 가리켰던 것과 다르다.
- 즉, 함수 호출이라는 것은 사실상 함수 적용을 가리키는 문법 설탕이나 다름 없다.
- apply()와 더불어 call() 메서드도 있다. 이는 함수의 매개변수가 단 하나일 때는 굳이 배열을 만들지 않고 요소 하나만 지정하는 방법이 더 편하기 때문에 call()을 쓰는 게 더 나을 때도 있다.

```jsx
sayHi.apply(alien, ["humans"]); // "Hello, humans!"
sayHi.call(alien, "humans"); // "Hello, humans!"
```

### 부분적인 적용



